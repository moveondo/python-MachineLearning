### 集成方法: ensemble method（元算法: meta algorithm） 概述

概念：是对其他算法进行组合的一种形式。

通俗来说： 当做重要决定时，大家可能都会考虑吸取多个专家而不只是一个人的意见。 机器学习处理问题时又何尝不是如此？ 这就是集成方法背后的思想。

#### 集成方法：

* 投票选举(bagging: 自举汇聚法 bootstrap aggregating): 是基于数据随机重抽样分类器构造的方法
* 再学习(boosting): 是基于所有分类器的加权求和的方法

#### 集成方法 场景

 * 目前 bagging 方法最流行的版本是: 随机森林(random forest)
   * 选男友：美女选择择偶对象的时候，会问几个闺蜜的建议，最后选择一个综合得分最高的一个作为男朋友

 * 目前 boosting 方法最流行的版本是: AdaBoost
   * 追女友：3个帅哥追同一个美女，第1个帅哥失败->(传授经验：姓名、家庭情况) 第2个帅哥失败->(传授经验：兴趣爱好、性格特点) 第3个帅哥成功

> bagging 和 boosting 区别是什么？

 * bagging 是一种与 boosting 很类似的技术, 所使用的多个分类器的类型（数据量和特征量）都是一致的。
 * bagging 是由不同的分类器（1.数据随机化 2.特征随机化）经过训练，综合得出的出现最多分类结果；boosting 是通过调整已有分类器错分的那些数据来获得新的分类器，得出目前最优的结果。
 * bagging 中的分类器权重是相等的；而 boosting 中的分类器加权求和，所以权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。

### 随机森林

#### 随机森林 概述

 * 随机森林指的是利用多棵树对样本进行训练并预测的一种分类器。
 * 决策树相当于一个大师，通过自己在数据集中学到的知识用于新数据的分类。但是俗话说得好，一个诸葛亮，玩不过三个臭皮匠。随机森林就是希望构建多个臭皮匠，希望最终的分类效果能够超过单个大师的一种算法。

#### 随机森林 原理

那随机森林具体如何构建呢？

有两个方面：

* 数据的随机性化
* 待选特征的随机化

使得随机森林中的决策树都能够彼此不同，提升系统的多样性，从而提升分类性能。

> 数据的随机化：使得随机森林中的决策树更普遍化一点，适合更多的场景。

（有放回的准确率在：70% 以上， 无放回的准确率在：60% 以上）

* 采取有放回的抽样方式 构造子数据集，保证不同子集之间的数量级一样（不同子集／同一子集 之间的元素可以重复）
* 利用子数据集来构建子决策树，将这个数据放到每个子决策树中，每个子决策树输出一个结果。
* 然后统计子决策树的投票结果，得到最终的分类 就是 随机森林的输出结果。
* 如下图，假设随机森林中有3棵子决策树，2棵子树的分类结果是A类，1棵子树的分类结果是B类，那么随机森林的分类结果就是A类。

 ![Image text](https://github.com/moveondo/python-MachineLearning/blob/master/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/image/1.jpg)


> 待选特征的随机化

 * 子树从所有的待选特征中随机选取一定的特征。
 * 在选取的特征中选取最优的特征。
 
下图中，蓝色的方块代表所有可以被选择的特征，也就是目前的待选特征；黄色的方块是分裂特征。

左边是一棵决策树的特征选取过程，通过在待选特征中选取最优的分裂特征（别忘了前文提到的ID3算法，C4.5算法，CART算法等等），完成分裂。

右边是一个随机森林中的子树的特征选取过程

 ![Image text](https://github.com/moveondo/python-MachineLearning/blob/master/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/image/2.jpg)


随机森林 开发流程

```
收集数据：任何方法
准备数据：转换样本集
分析数据：任何方法
训练算法：通过数据随机化和特征随机化，进行多实例的分类评估
测试算法：计算错误率
使用算法：输入样本数据，然后运行 随机森林 算法判断输入数据分类属于哪个分类，最后对计算出的分类执行后续处理

```

随机森林 算法特点

```
优点：几乎不需要输入准备、可实现隐式特征选择、训练速度非常快、其他模型很难超越、很难建立一个糟糕的随机森林模型、大量优秀、免费以及开源的实现。
缺点：劣势在于模型大小、是个很难去解释的黑盒子。
适用数据范围：数值型和标称型

```

### AdaBoost (adaptive boosting: 自适应 boosting) 概述

能否使用弱分类器和多个实例来构建一个强分类器？ 这是一个非常有趣的理论问题。

### AdaBoost 原理

> AdaBoost 工作原理

 ![Image text](https://github.com/moveondo/python-MachineLearning/blob/master/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/image/3.jpg)

> AdaBoost 开发流程

```
收集数据：可以使用任意方法
准备数据：依赖于所使用的弱分类器类型，本章使用的是单层决策树，这种分类器可以处理任何数据类型。
    当然也可以使用任意分类器作为弱分类器，第2章到第6章中的任一分类器都可以充当弱分类器。
    作为弱分类器，简单分类器的效果更好。
分析数据：可以使用任意方法。
训练算法：AdaBoost 的大部分时间都用在训练上，分类器将多次在同一数据集上训练弱分类器。
测试算法：计算分类的错误率。
使用算法：通SVM一样，AdaBoost 预测两个类别中的一个。如果想把它应用到多个类别的场景，那么就要像多类 SVM 中的做法一样对 AdaBoost 进行修改。

```
> AdaBoost 算法特点

* 优点：泛化（由具体的、个别的扩大为一般的）错误率低，易编码，可以应用在大部分分类器上，无参数调节。
* 缺点：对离群点敏感。
* 适用数据类型：数值型和标称型数据。

#### 基于单层决策树构建弱分类器

 * 单层决策树(decision stump, 也称决策树桩)是一种简单的决策树。


