### logistic 回归

Logistic 回归 或者叫逻辑回归 虽然名字有回归，但是它是用来做分类的。其主要思想是: 根据现有数据对分类边界线(Decision Boundary)建立回归公式，以此进行分类。


#### 基于最优化方法的回归系数确定

Sigmoid 函数的输入记为 z ，由下面公式得到:

<img width="150" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/4.jpg"/>

如果采用向量的写法，上述公式可以写成<img width="150" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/5.jpg"/>
 ,它表示将这两个数值向量对应元素相乘然后全部加起来即得到 z 值。其中的向量 x 是分类器的输入数据，向量 w 也就是我们要找到的最佳参数（系数），从而使得分类器尽可能地精确。为了寻找该最佳参数，需要用到最优化理论的一些知识。我们这里使用的是——梯度上升法（Gradient Ascent）。


#### 梯度上升法

  梯度的介绍
  
  需要一点点向量方面的数学知识
```

向量 = 值 + 方向  
梯度 = 向量
梯度 = 梯度值 + 梯度方向

```
梯度算子总是指向函数值增长最快的方向。这里所说的是移动方向，而未提到移动量的大小。该量值称为步长，记作 α 。用向量来表示的话，梯度上升算法的迭代公式如下:

<img width="150" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/6.jpg"/>


 一些概念：
 
```
例如：y = w0 + w1x1 + w2x2 + ... + wnxn
梯度：参考上图的例子，二维图像，x方向代表第一个系数，也就是 w1，y方向代表第二个系数也就是 w2，这样的向量就是梯度。
α：上面的梯度算法的迭代公式中的阿尔法，这个代表的是移动步长（step length）。移动步长会影响最终结果的拟合程度，最好的方法就是随着迭代次数更改移动步长。
步长通俗的理解，100米，如果我一步走10米，我需要走10步；如果一步走20米，我只需要走5步。这里的一步走多少米就是步长的意思。
▽f(w)：代表沿着梯度变化的方向。
```
梯度算子总是指向函数值增长最快的方向。这里所说的是移动方向，而未提到移动量的大小。该量值称为步长，记作 α 。用向量来表示的话，梯度上升算法的迭代公式如下:
问：有人会好奇为什么有些书籍上说的是梯度下降法（Gradient Decent）?

答： 其实这个两个方法在此情况下本质上是相同的。关键在于代价函数（cost function）或者叫目标函数（objective function）。如果目标函数是损失函数，那就是最小化损失函数来求函数的最小值，就用梯度下降。 如果目标函数是似然函数（Likelihood function），就是要最大化似然函数来求函数的最大值，那就用梯度上升。在逻辑回归中， 损失函数和似然函数无非就是互为正负关系。

只需要在迭代公式中的加法变成减法。因此，对应的公式可以写成

<img width="150" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/7.jpg"/>


### 局部最优现象 （Local Optima）

<img src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/8.jpg"/>

上图表示参数 θ 与误差函数 J(θ) 的关系图 (这里的误差函数是损失函数，所以我们要最小化损失函数)，红色的部分是表示 J(θ) 有着比较高的取值，我们需要的是，能够让 J(θ) 的值尽量的低。也就是深蓝色的部分。θ0，θ1 表示 θ 向量的两个维度（此处的θ0，θ1是x0和x1的系数，也对应的是上文w0和w1）。

可能梯度下降的最终点并非是全局最小点，可能是一个局部最小点，如我们上图中的右边的梯度下降曲线，描述的是最终到达一个局部最小点，这是我们重新选择了一个初始点得到的。

看来我们这个算法将会在很大的程度上被初始点的选择影响而陷入局部最小点。


#### logistic 回归和线性回归的区别

logistic 回归和线性回归的区别是：线性回归是根据样本X各个维度的Xi的线性叠加（线性叠加的权重系数wi就是模型的参数）来得到预测值的Y，然后最小化所有的样本预测值Y与真实值y'的误差来求得模型参数。我们看到这里的模型的值Y是样本X各个维度的Xi的线性叠加，是线性的。

Y=WX (假设W>0),Y的大小是随着X各个维度的叠加和的大小线性增加的，如图（x为了方便取1维）：

![Image text](https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/1.jpg)


然后再来看看我们这里的logistic 回归模型，模型公式是：[main]，这里假设W>0,Y与X各维度叠加和（这里都是线性叠加W）的图形关系，如图（x为了方便取1维）：

![Image text](https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/2.jpg)



我们看到Y的值大小不是随X叠加和的大小线性的变化了，而是一种平滑的变化，这种变化在x的叠加和为0附近的时候变化的很快，而在很大很大或很小很小的时候，X叠加和再大或再小，Y值的变化几乎就已经很小了。当X各维度叠加和取无穷大的时候，Y趋近于1，当X各维度叠加和取无穷小的时候，Y趋近于0.


这种变量与因变量的变化形式就叫做logistic变化。（注意不是说X各个维度和为无穷大的时候，Y值就趋近1，这是在基于W>0的基础上，（如果W<0,n那么Y趋近于0）而W是根据样本训练出来，可能是大于0，也可能是小0，还可能W1>0，W2<0…所以这个w值是样本自动训练出来的，也因此不是说你只要x1，x2，x3…各个维度都很大，那么Y值就趋近于1，这是错误的。凭直觉想一下也不对，因为你连样本都还没训练，你的模型就有一个特点：X很大的时候Y就很大。这种强假设肯定是不对的。因为可能样本的特点是X很大的时候Y就很小。）


所以我们看到，在logistic回归中，X各维度叠加和（或X各维度）与Y不是线性关系，而是logistic关系。而在线性回归中，X各维度叠加和就是Y，也就是Y与X就是线性的了。

X各维度叠加和Y的关系不只是这一种，还可能是其他的比如：

![Image text](https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/3.jpg)


为什么变量与因变量要选用logistic关系呢，因为这里（1）我们需要Y代表的是概率即Y∈（0,1）。（2）我们需要X各维度叠加和在0附近变化幅度比较大，并且是非线性的变化。而在很大或很小的时候，几乎不变化，这是基于概率的一种认识与需要。感性的一个例子，想想你学习努力的程度与从60分提高到80分和80提高到100分并不是线性的。（3）这个关系的公式要在之后形成的cost function是凸函数。

所以就选择了logistic。


前面已经说了，我们使用logistic回归是用于二分类问题（y只有两个值A,B，也可以写成1和0，这都没关系），回归模型得到的结果不是预测样本X对应的y值（注意下，在logistic回归这里我们小写y表示某个样本Xi的类别，而大写Y或Y(Xi)表示logistic回归模型对某个样本Xi预测为1的概率。其实这里最好把Y用其他字母表示，以免混淆，但是已经这里写了，以后注意。），而是y=1的概率或y=0的概率。
我们假设y=1的概率公式是： <img width="150" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/main1.jpg"/>，
那么y=0的概率就是 <img width="150" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/main2.jpg"/>
。
（注意我们也可以y=0的概率公式为前面那一个，这里是任意的。这里不同的结果只是最终的W参数不同罢了。因为我们最终的W是训练出来的，不管怎么样，模型都会表现出样本的特点来。只是我们习惯了把Y(X)当成y=1的logistic模型映射的概率）


还要注意这里我们不是对一个Xi都要分别预测出来y=1的概率和y=0的概率。而是对于一个Xi，如果它的yi=1，那么我们就用 <img width="150" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/main1.jpg"/>，
这个公式映射所对应的概率，如果对于一个Xi，如果它的yi=0，那么我们就用 <img width="150" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/main2.jpg"/>，这个公式映射所对应的概率。都是根据yi的值映射出来一个概率。

因为我们的Y是概率，我们不能利用最小误差等，我们这里用的是极大化所有样本的对数似然函数： <img width="400" src="https://github.com/moveondo/python-MachineLearning/blob/master/logistic/image/main4.jpg"/>，。


yi表示的是Xi真实所属的类别（1或0）。L（W）就是cost function。这里的目标函数值和W有关系，也就是X各维度线性叠加的那些权重有关系。


### Logistic 回归 原理

#### Logistic 回归 工作原理

```

每个回归系数初始化为 1
重复 R 次:
    计算整个数据集的梯度
    使用 步长 x 梯度 更新回归系数的向量
返回回归系数

```

#### Logistic 回归 开发流程

```
收集数据: 采用任意方法收集数据
准备数据: 由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。
分析数据: 采用任意方法对数据进行分析。
训练算法: 大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。
测试算法: 一旦训练步骤完成，分类将会很快。
使用算法: 首先，我们需要输入一些数据，并将其转换成对应的结构化数值；
         接着，基于训练好的回归系数就可以对这些数值进行简单的回归计算，判定它们属于哪个类别；
         最后，我们就可以在输出的类别上做一些其他分析工作。

```

#### 特点：

* 优点: 计算代价不高，易于理解和实现。
* 缺点: 容易欠拟合，分类精度可能不高。
* 适用数据类型: 数值型和标称型数据。


#### 其他

在上文中，当Sigmoid函数大于 0.5 的数据被分入 1 类，小于 0.5 即被归入 0 类。其实0.5也是可以改动的。 比如大于 0.9 的数据被分入 1 类，小于 0.9 即被归入 0 类。

##### Logistic回归 和 最大熵模型

Logistic回归和最大熵模型 都属于对数线性模型 （log linear model）。
 当类标签（class label）只有两个的时候，最大熵模型就是 logistic 回归模型。 
 学习它们的模型一般采用极大似然估计或者正则化的极大似然估计。Logistic 回归和最大熵模型学习可以形式化为无约束最优化问题。（关于最大熵模型，可以阅读《统计学习方法》 第六章。）

##### 其他算法

除了梯度下降，随机梯度下降，还有Conjugate Gradient，BFGS，L-BFGS，他们不需要指定alpha值（步长），而且比梯度下降更快，在现实中应用的也比较多。 当然这些算法相比随机梯度要复杂。

综上这些算法都有一个共通的缺点就是他们都是不断去逼近真实值，永远只是一个真实值的近似值而已。

#### 多标签分类

逻辑回归也可以用作于多标签分类。 思路如下：

假设我们标签A中有a0,a1,a2....an个标签，对于每个标签 ai (ai 是标签A之一)，我们训练一个逻辑回归分类器。

即，训练该标签的逻辑回归分类器的时候，将ai看作一类标签，非ai的所有标签看作一类标签。那么相当于整个数据集里面只有两类标签：ai 和其他。

剩下步骤就跟我们训练正常的逻辑回归分类器一样了。

测试数据的时候，将查询点套用在每个逻辑回归分类器中的Sigmoid 函数，取值最高的对应标签为查询点的标签。




