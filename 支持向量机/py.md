
### mat 矩阵创建

```
data1=mat(zeros((3,3)));
#创建一个3*3的零矩阵，矩阵这里zeros函数的参数是一个tuple类型(3,3)
data2=mat(ones((2,4)));
#创建一个2*4的1矩阵，默认是浮点型的数据，如果需要时int类型，可以使用dtype=int
data3=mat(random.rand(2,2));
#这里的random模块使用的是numpy中的random模块，random.rand(2,2)创建的是一个二维数组，需要将其转换成#matrix
data4=mat(random.randint(10,size=(3,3)));
#生成一个3*3的0-10之间的随机整数矩阵，如果需要指定下界则可以多加一个参数
data5=mat(random.randint(2,8,size=(2,5));
#产生一个2-8之间的随机整数矩阵
data6=mat(eye(2,2,dtype=int));
#产生一个2*2的对角矩阵
a1=[1,2,3];
a2=mat(diag(a1));
#生成一个对角线为1、2、3的对角矩阵

```

### transpose()函数

```
a = array([[[ 0,  1,  2,  3],
                [ 4,  5,  6,  7]],
               [[ 8,  9, 10, 11],
                [12, 13, 14, 15]]])
                
b = a.transpose(１，０，２)
 
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],
       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])

```

数组a中10的坐标为a（1,0,3），经过transpose(1,0,2)转置后的数组ｂ中的10的坐标为b（0,1,3）。
原始的transpose参数(默认的参数)为(0,1,2)，这个转置相当于将第一个坐标与第二坐标进行了互换


总结：对于多维数组，特别是三维以上的数组，每个元素（最底层的不可分割的）需要有多个索引确定，三维就需要三个索引，四维就需要四个索引，依次类推。
每一个维的索引都是从0开始算，至于每一个维多少个索引，都需要人为或者机器去定，有多少维，每一个维多少个索引决定着数组的形状（shape)千差万别）。
每一个维的索引个数其实就决定着每一个维的弹性大小。除了讨论有多少维，每一个维多少个索引外，其实我们都有一个默认的约定的一直没讨论到的东西，那就是每一个维在所有维当中的一个排序，而transpose函数就是改变了原来数组的维的排序，从而导致整个数组发生了翻天覆地的变换。


### 转置

转置可以对数组进行重置，返回的是源数据的视图（不会进行任何复制操作）。
转置有三种方式，transpose方法、T属性以及swapaxes方法


### numpy函数库：对数组进行处理

ufunc函数: ufunc是universal function的缩写，它是一种能对数组的每个元素进行操作的函数。
NumPy内置的许多ufunc函数都是在C语言级别实现的，因此它们的计算速度非常快。


当我们使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算，因此它要求这两个数组有相同的大小(shape相同)。如果两个数组的shape不同的话，会进行如下的广播(broadcasting)处理：

```

1,让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐
2,输出数组的shape是输入数组shape的各个轴上的最大值
3,如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为1时，这个数组能够用来计算，否则出错
4,当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值

```